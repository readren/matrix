package readren.matrix
package cluster.service

import cluster.*
import cluster.serialization.MacroTools.showCode
import cluster.serialization.NestedSumMatchMode.{FLAT, TREE}
import cluster.serialization.{Deserializer, DiscriminationCriteria, ProtocolVersion, Serializer}
import cluster.service.Protocol.*

import readren.taskflow.Maybe
import readren.taskflow.SchedulingExtension.MilliDuration

import java.net.SocketAddress
import scala.compiletime.erasedValue
import scala.util.control.NonFatal

sealed trait Protocol

/** A message sent to a peer that is self-initiated, rather than being a response to a prior message from that peer. */
sealed trait InitiationMsg extends Protocol

/** A message that spontaneously affirms a fact without expecting a response. */
sealed trait Affirmation extends InitiationMsg

/** A message that asks for a response from the receiver, but may affirm something too. */
sealed trait Request extends InitiationMsg {
	type ResponseType <: Response
	val requestId: RequestId
}

/** A message that responds a [[Request]] message to that [[Request]]'s sender. */
sealed trait Response extends Protocol {
	val toRequest: RequestId
}

sealed trait Hello extends Request {
	val myContactAddress: ContactAddress
	val myMembershipStatus: MembershipStatus
}

/** The first message that a participant sends to another participant after successfully connecting as a client. This message serves to:
 * 	- announce the sender's existence and share knowledge of other participants it knows about;
 *  - communicate the sender's current membership status to the peer;
 * 	- negotiate protocol version compatibility with the peer;
 * 	- request a response from the peer: either [[Welcome]] if versions are compatible, or [[SupportedVersionsMismatch]] if not.
 * 	
 * 	@param requestId unique identifier for this request (auto-generated by [[CommunicableDelegate.askPeer]]) that the receiver must use when replying.
 * 	@param myContactAddress the contact address of the sender.
 * 	@param versionsISupport the set of protocol versions supported by the sender.
 * 	@param myCreationInstant the instant when the sender's [[ParticipantService]] instance was created.
 * 	@param myMembershipStatus the current membership status of the sender.
 * 	@param otherParticipantsIKnow the addresses of participants known by the sender (excluding itself). */
case class HelloIExist(override val requestId: RequestId, override val myContactAddress: ContactAddress, versionsISupport: Set[ProtocolVersion], myCreationInstant: Instant, myMembershipStatus: MembershipStatus, otherParticipantsIKnow: Set[ContactAddress]) extends Hello {
	override type ResponseType = Welcome | SupportedVersionsMismatch
}

/** The first message that a participant sends to the peer after a successful reconnection. Its purpose is to:
 * - update the peer's viewpoint of the sender.
 * 	- ask the peer to decide which protocol version to use with him.
 * 	- expect the peer to reply with [[Welcome]] if there is version compatibility or with [[SupportedVersionsMismatch]] otherwise. */
case class HelloIAmBack(override val requestId: RequestId, override val myContactAddress: ContactAddress, versionsISupport: Set[ProtocolVersion], myCreationInstant: Instant, myMembershipStatus: MembershipStatus) extends Hello {
	override type ResponseType = Welcome | SupportedVersionsMismatch
}

/**
 * Response to the [[HelloIExist]] message that is sent by a participant to indicate that it does not support any of the [[ProtocolVersion]]s specified in the received [[HelloIExist]] message.
 * */
case class SupportedVersionsMismatch(override val toRequest: RequestId) extends Response

/** Response to the [[HelloIExist]] and [[HelloIAmBack]] messages when there is version compatibility.
 *
 * @param myMembershipStatus the [[MembershipStatus]] of the sender.
 * @param versionsISupport the versions supported by the sender.
 * @param otherParticipants the participants known by the sender, excluding itself.
 */
case class Welcome(override val toRequest: RequestId, myMembershipStatus: MembershipStatus, versionsISupport: Set[ProtocolVersion], myCreationInstant: Instant, otherParticipants: Set[ContactAddress]) extends Response

/** Message sent by an aspirant A to an aspirant B when A starts or stops proposing B to be the creator of the cluster.
 * An aspirant starts proposing a candidate when, from his viewpoint, he is communicated to all the seeds he knows and the connection to all the others he knows is completed (successfully or not).
 * The chosen aspirant is the one with the lowest [[ContactAddress]] that supports the newest [[ProtocolVersion]] among all the versions supported by the aspirants he knows.
 * @param proposedCandidate the [[ContactAddress]] of the cluster's creator candidate proposed by the sender.
 * */
case class ClusterCreatorProposal(proposedCandidate: Maybe[ContactAddress]) extends Affirmation

/** Informs that the sender has created a cluster.
 * This message is sent to all known aspirants after having created a cluster, which happens after all aspirants known by the sender have sent [[ClusterCreatorProposal]] message to the sender proposing him.
 *
 * @param myViewpoint the [[MemberViewpoint]]s of the sender, which is the cluster creator. */
case class ICreatedACluster(myViewpoint: MemberViewpoint) extends Affirmation

/** The message sent by an aspirant to each member of the cluster to get its permission to join (in the form a token). */
@deprecated
case class RequestApprovalToJoin(override val requestId: RequestId) extends Request {
	override type ResponseType = JoinApprovalGranted
}

/** Response to the [[RequestApprovalToJoin]]
 *
 * @param joinToken a value that constates the responding member approves the join request. */
@deprecated
case class JoinApprovalGranted(override val toRequest: RequestId, joinToken: JoinToken) extends Response


/** Command message that an aspirant has to send to any member in order to join the cluster.
 *
 * @param joinTokenByMemberAddress the join-token provided by each approving member. */
case class RequestToJoin(override val requestId: RequestId, clusterId: ClusterId, joinTokenByMemberAddress: Map[ContactAddress, JoinToken]) extends Request {
	override type ResponseType = JoinGranted | JoinRejected
}

/** Response to the [[RequestToJoin]] message when the join is granted, and at the same time, a request for a [[JoinDecision]] acknowledgment.
 * @param participantInfoByItsAddress the state of all the participant according to the sender, including his own view of himself (which is the single source of that information).
 */
case class JoinGranted(override val toRequest: RequestId, override val requestId: RequestId, participantInfoByItsAddress: Map[ContactAddress, ParticipantInfo]) extends Response, Request {
	override type ResponseType = JoinDecision
}

/** Response to the [[RequestToJoin]] message when the join is not successful with the motive of the rejection. */
case class JoinRejected(override val toRequest: RequestId, youHaveToRetrySoon: Boolean, aMemberIsNotStable: Boolean, ourKnownMembersSetDoNotMatch: Boolean, iAmIsolated: Boolean, thereIsAClustersConflict: Boolean) extends Response

/** Acknowledgment to the `JoinGranted` message. */
case class JoinDecision(override val toRequest: RequestId, accepted: Boolean) extends Response

/**
 * Informs the receiver the membership-status of the sender and reveals his memory of the membership-status of other participants.
 * Sent by participant A to participant B when A notices that B's memory of the membership-status of A is incorrect. For example, it is sent by the receiver of a [[ClusterCreatorProposal]] when he knows of the existence of a cluster, and by the receiver of a [[RequestToJoin]] when he is an aspirant.
 * @param membershipStatusOfParticipantsIKnow the [[MembershipStatus]] of the participants that the sender knows according to him, including the receiver.
 */
case class WaitMyMembershipStatusIs(myMembershipStatus: MembershipStatus, membershipStatusOfParticipantsIKnow: Map[ContactAddress, MembershipStatus]) extends Affirmation

/** The message sent by a participant to as many other participants as possible before leaving the network or shooting down. */
case class Farewell(myCreationInstant: Instant) extends Affirmation

/** The message sent to other participants after receiving a [[Farewell]] message. */
case class AnotherParticipantGone(goneParticipantAddress: ContactAddress, goneParticipantCreationInstant: Instant) extends Affirmation

/** The message sent by a participant A to another B when A has doubts about his communication-status with B and/or B's knowledge about A's membership status.  */
case class AreYouInSyncWithMe(override val requestId: RequestId, myMembershipStatus: MembershipStatus, yourMembershipStatusAccordingToMe: MembershipStatus) extends Request {
	override type ResponseType = AreWeInSyncResponse
}

/** Response to the [[AreYouInSyncWithMe]] query. */
case class AreWeInSyncResponse(override val toRequest: RequestId, yourMembershipStatusAccordingToMeMatches: Boolean) extends Response

/** The message that a participant sends to all other participants it knows when it notices the communication between it and another participant is not working properly. */
case class ILostCommunicationWith(participantsAddress: ContactAddress) extends Affirmation

/** The message that a participant sends to all other participants it knows when it starts, or restarts, a conversation with another participant. */
case class ConversationStartedWith(participantAddress: ContactAddress, isARestartAfterReconnection: Boolean) extends Affirmation

/** The message that a participant A sends to all other participants when A receives a [[HelloIExist]] from a participant B that A already knows and remembers as a member. Why? Because the [[HelloIExist]] message is only sent by aspirants (not members) when the communication starts. */
case class AMemberHasBeenRebooted(rebootedParticipantAddress: ContactAddress, restartedParticipantCreationInstant: Instant) extends Affirmation

/** The message that every participant sends to every other participant it knows to verify the communication channel that connects them is working. */
case class Heartbeat(delayUntilNextHeartbeat: MilliDuration) extends Affirmation

/** A message that a participant sends to all the participants it knows when his state, or his viewpoint of another participant's state, changes.
 *
 * @param myStateSerial the sender's current-state serial-number.
 * @param takenOn the instant at which this message was created.
 * @param myMembershipStatus the membership-status of the sender.
 * @param participantInfoByAddress the information, according to the sender, about each participant by its address. */
case class ClusterStateChanged(myStateSerial: RingSerial, takenOn: Instant, myMembershipStatus: MembershipStatus, participantInfoByAddress: Map[ContactAddress, ParticipantInfo]) extends Affirmation


/** The message that a participant's delegate sends to inform the peer delegate that he called [[AsynchronousSocketChannel.shutdownInput]] because the channel was discarded due to duplicate connections. */
case object ChannelDiscarded extends Affirmation

/** The message sent to all other members when a member discovers the existence of another cluster, to start a brain join process. */
case class WeHaveToResolveBrainJoin(myViewPoint: MemberViewpoint) extends Affirmation

/** The message sent to all other members when a member suspects that a brain split occurred (many other members suddenly become unreachable), to start the process that determines if the division where the sender resides should persist or be shutdown. */
case class WeHaveToResolveBrainSplit(myViewPoint: MemberViewpoint) extends Affirmation

case class ApplicationMsg(bytes: Array[Byte]) extends Affirmation


object Protocol {

	import cluster.channel.Nio2Serializers.given

	import serialization.CommonSerializers.given

	type ContactAddress = SocketAddress
	type JoinToken = Long
	/** Milliseconds since 1970-01-01T00:00:00Z */
	type Instant = Long
	opaque type ClusterId = Instant
	inline def generateClusterId(clusterCreationInstant: Instant): ClusterId = clusterCreationInstant 

	type RequestId = Short // changing this type requires updating the `incremented` method implementation below.
	extension (requestId: RequestId) {
		inline def incremented: RequestId = (requestId + 1).toShort
	}

	val UNSPECIFIED_INSTANT: Instant = Long.MaxValue



	sealed trait MembershipStatus

	/** An aspirant to become a member.  */
	case object Aspirant extends MembershipStatus

	sealed trait Member extends MembershipStatus {
		/** The identifier of the cluster I am a member of. */
		val clusterId: ClusterId
	}

	/** A fully functional member of the specified cluster. */
	case class Functional(override val clusterId: ClusterId) extends Member

	/** A member of the specified cluster that has detected that half or more of the members he knows were simultaneously unreachable.
	 * Isolated members do not accept join request and remain in this state, even after reconnecting to the majority of the known members, until user intervention. */
	case class Isolated(override val clusterId: ClusterId) extends Member

	/** A member of the specified cluster that had detected another cluster.
	 * Conflicted members do not accept join requests and remain in this state until the user intervention */
	case class Conflicted(override val clusterId: ClusterId, foreignClustersIds: Set[ClusterId], wasIsolated: Boolean) extends Member


	given Serializer[MembershipStatus] = Serializer.derive[MembershipStatus](FLAT)

	given Deserializer[MembershipStatus] = Deserializer.derive[MembershipStatus](FLAT)

	enum IncommunicabilityReason {
		case IS_CONNECTING_AS_CLIENT, IS_INCOMPATIBLE
	}

	given Serializer[IncommunicabilityReason] = Serializer.derive[IncommunicabilityReason](FLAT)

	given Deserializer[IncommunicabilityReason] = Deserializer.derive[IncommunicabilityReason](FLAT)

	/**
	 * Information that tells how a participant sees another participant
	 * @param communicationStatus the communication status that the sender of this information has toward the referred participant.
	 * @param membershipStatus the membership status of the referred participant according to the sender of this information.
	 */
	case class ParticipantInfo(communicationStatus: CommunicationStatus, membershipStatus: MembershipStatus)

	given Serializer[ParticipantInfo] = Serializer.derive[ParticipantInfo](FLAT)

	given Deserializer[ParticipantInfo] = Deserializer.derive[ParticipantInfo](FLAT)

	/** A photo of the community's state from the viewpoint of a member.
	 * @param serial the serial number (or revision) that identifies the photo of the member's viewpoint-state from previous photos.
	 * @param takenOn the [[Instant]] when this photo was taken.
	 * @param clusterId the identifier of the cluster to which the member belongs.
	 * @param participantsInfo the information about each participant in the community that the member had when the photo was taken. */
	case class MemberViewpoint(serial: RingSerial, takenOn: Instant, clusterId: ClusterId, participantsInfo: Map[ContactAddress, ParticipantInfo])

	given Serializer[MemberViewpoint] = Serializer.derive[MemberViewpoint](FLAT)

	given Deserializer[MemberViewpoint] = Deserializer.derive[MemberViewpoint](FLAT)

	enum CommunicationStatus {
		case HANDSHOOK, CONNECTED, CONNECTING, INCOMPATIBLE, UNREACHABLE
	}

	given Serializer[CommunicationStatus] = Serializer.derive[CommunicationStatus](FLAT)

	given Deserializer[CommunicationStatus] = Deserializer.derive[CommunicationStatus](FLAT)

	private val protocolSerializer: Serializer[Protocol] = showCode(Serializer.derive[Protocol](FLAT))

	given Serializer[Protocol] = protocolSerializer

	private val protocolDeserializer: Deserializer[Protocol] = showCode(Deserializer.derive[Protocol](FLAT))

	given Deserializer[Protocol] = protocolDeserializer


	object protocolDc extends DiscriminationCriteria[Protocol] {
		override transparent inline def discriminator[P <: Protocol]: Int =
			inline erasedValue[P] match {
				case _: HelloIExist => 10
				case _: HelloIAmBack => 11
				case _: SupportedVersionsMismatch => 13
				case _: Welcome => 14
				case _: ClusterCreatorProposal => 20
				case _: ICreatedACluster => 21
				case _: RequestApprovalToJoin => 30
				case _: JoinApprovalGranted => 31
				case _: RequestToJoin => 32
				case _: JoinGranted => 33
				case _: JoinRejected => 34
				case _: JoinDecision => 35
				case _: WaitMyMembershipStatusIs => 40
				case _: Farewell => 41
				case _: AnotherParticipantGone => 42
				case _: AreYouInSyncWithMe => 43
				case _: AreWeInSyncResponse => 44
				case _: ILostCommunicationWith => 45
				case _: ConversationStartedWith => 46
				case _: AMemberHasBeenRebooted => 47
				case _: Heartbeat => 48
				case _: ClusterStateChanged => 49
				case ChannelDiscarded => 50
				case _: WeHaveToResolveBrainJoin => 51
				case _: WeHaveToResolveBrainSplit => 52
				case _: ApplicationMsg => 60

				case _: Hello => 5
				case _: Request => 4
				case _: Affirmation => 3
				case _: InitiationMsg => 2
				case _: Response => 1
			}
	}

	transparent inline given DiscriminationCriteria[Protocol] = protocolDc

}